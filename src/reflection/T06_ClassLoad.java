package reflection;

/**
 * @author TuanFans
 * @date 2025/4/12
 * @description 类加载
 */
//反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。
//1.静态加载：编译时加载相关的类，如果没有则报错，依赖性太强（new创建对象）
//2.动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性（反射）
//类加载时机
//1.当创建对象时 (new)
//2.当子类被加载时，父类也会被加载
//3.调用类中的静态成员时
//4.通过反射
//类加载的三个阶段：加载、连接（验证、准备、解析）、初始化
//1.加载：将类的字节码加载到内存中，并生成一个Class对象；由加载器完成
//2.连接：将类的二进制数据合并到JRE中；由连接器完成。
    //1.验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
        // 包括：文件格式验证（是否以魔数cafebabe(0x)开头）、元数据验证、字节码验证和符号引用验证
        // 可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。
    //2.准备：JVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如O、OL、null、false等）。这些变量所使用的内存都将在方法区中进行分配
    //3.解析：解析器将常量池内的符号引用替换为直接引用，直接引用就是具体值。
//3.初始化：JVM负责对类进行初始化，这里主要是指静态成员
    //1.执行<clinit>()方法的过程。
    //2.<clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。
    //3.虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，
        //那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕
public class T06_ClassLoad {

}

/*
* 分析类加载准备阶段的处理
* 1.a是实例属性（只有实例化的对象才有这个属性），非静态变量，所以在准备阶段不会分配内存；
* 2.b是静态属性，静态变量，所以在准备阶段会分配内存并初始化（默认初始值为0）；
* 3.c是常量，在准备阶段会分配内存并初始化为1；
* */
class A{
    public int a = 1;
    public static int b = 1;
    public static final int c = 1;
}
